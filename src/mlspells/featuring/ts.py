import pandas as pd
import numpy as np

from mlspells.featuring import AggregationFunc
from typing import Dict, Union, List, Any, Callable

def lag_columns(data: pd.DataFrame, columns: Union[str, List[str]], lag_columns: Union[int, None] = None, 
                lag_by: Union[int, List[int]] = 1, agg: Union[str, Callable, AggregationFunc] = None,
                grouping: List[str] = None, drop_nulls: bool = True):
    """
    Adds one or many lag columns into the data set. Multiple lag columns can be generated by indicating `lag_columns`
    or by passing a list in `lag_by`. If `lag_by` is a number and `lag_columns` is indicated, then multiple lag
    columns are generated by equally spacing them by `lag_by`. Aggregation is also possible.

    Parameters
    ----------
    data : pd.DataFrame
        Input data.
    column : Union[str, List[str]]
        Name of the column(s) to generate the lag columns from.
    lag_columns : int
        Number of lag columns to generate for each column indicated. If multiple `lag_by` values are indicated, then
        `lag_columns` should not be indicated.
    lag_by : Union[int, List[int]], optional
        Number of time-steps for each lag column, by default 1. If indicated as a list, then 
    agg : Union[str, function], optional
        Indicates the aggregation function to be used.
    drop_nulls : bool, optional
        Indicates if rows with `null` values should be dropped from the dataset, by default True

    Raises
    ------
    ValueError
        If an invalid lag value is indicated.
    """
    
    if isinstance(columns, str):
        column_names = [column]
    else:
        column_names = columns

    if isinstance(lag_by, list):
        assert len(lag_by) == lag_columns or not lag_columns, "Incompatible values for lag_by and lag_columns."
        assert not agg or (len(lag_by) == 1 or np.all(np.diff(lag_by) == lag_by[0] - lag_by[1])), "Lag values need to be equally spaced to use aggregations"
    elif isinstance(lag_by, int): 
        if not lag_columns:
            lag_columns = 1
        if lag_by <= 0:
            raise ValueError("Parameter lag_by is incorrect. It has to be different of zero")
    else:
        raise ValueError("Parameter lag_by of an unsupported type.")

    for column in column_names:
        if isinstance(lag_by, int):
            for lag in range(1, lag_columns+1):
                if agg:
                    data[f'{column}_lag{lag*lag_by}_{str(agg)}_{lag_by}'] = _wrap_group(data, grouping)[column].rolling(lag*lag_by, step=lag_by, center=False).agg(agg)
                else:
                    data[f'{column}_lag{lag*lag_by}'] = _wrap_group(data, grouping)[column].shift(lag*lag_by)
        else:
            for lag in lag_by:
                if agg:
                    diff = lag_by[1] - lag_by[0] if len(lag_by) > 1 else lag_by[0]
                    data[f'{column}_lag{lag}_{str(agg)}_{diff}'] = _wrap_group(data, grouping)[column].rolling(lag, step=diff, center=False).agg(agg)
                else:
                    data[f'{column}_lag{lag}'] = _wrap_group(data, grouping)[column].shift(lag)

    if drop_nulls:
        data.dropna(inplace=True)

def _wrap_group(df, grouping):
    if grouping:
        return df.groupby(grouping)
    return df